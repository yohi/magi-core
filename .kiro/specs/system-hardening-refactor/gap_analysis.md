# ギャップ分析: System Hardening Refactor

## 1. 現状の調査 (Current State Investigation)

既存のコードベース（`magi-core`）を調査し、要件に対する現状の実装状況と課題を特定しました。

### ドメイン資産と構造
*   **PluginLoader (`src/magi/plugins/loader.py`)**:
    *   `path.read_text` による同期的なファイル読み込みが行われており、非同期イベントループをブロックするリスクがあります。
    *   バリデーションは `isinstance` を多用した手動チェックで実装されており、保守性が低く脆弱です。
    *   署名検証 (`_verify_security`) も同期的に実行されており、計算コストの高い処理がメインスレッドを占有します。
    *   公開鍵パスの解決にカレントディレクトリ (`CWD/plugins/public_key.pem`) を含んでおり、本番環境でのセキュリティリスクがあります。
*   **ConsensusEngine (`src/magi/core/consensus.py`)**:
    *   コンストラクタ内で `PersonaManager`, `ContextManager` を直接インスタンス化しており、DI（依存性注入）が不完全で単体テストが困難です。
    *   `_run_thinking_phase` および `_run_debate_phase` にて `asyncio.gather` を使用していますが、同時実行数の制限（セマフォ）がなく、APIレート制限に抵触するリスクがあります。
*   **ConfigManager (`src/magi/config/manager.py`)**:
    *   `dataclass` と手動のバリデーションロジックで実装されています。Pydantic 等の宣言的なバリデーションは使用されていません。
    *   環境変数のマッピングと型変換が手動で行われており、拡張時にミスが発生しやすい構造です。
*   **LLMClient (`src/magi/llm/client.py`)**:
    *   モデル名やタイムアウトのデフォルト値がコード内にハードコードされています。
    *   グローバルな同時実行数制御（Rate Limit以外）の仕組みを持っていません。
*   **StreamingEmitter (`src/magi/core/streaming.py`)**:
    *   `QueueStreamingEmitter` はバッファ溢れ時に `put_nowait` で例外をキャッチしてドロップする挙動となっており、バックプレッシャー（待機）制御が不十分です。
*   **Guardrails (`src/magi/security/guardrails.py`)**:
    *   正規表現ベースの簡易な検知のみが実装されており、拡張のためのインターフェースはあるものの、高度な解析を行うプロバイダは未実装です。

### 統合ポイント
*   **設定**: 環境変数とYAMLファイルからのロード。`magi.yaml` が中心。
*   **非同期処理**: `asyncio` を全面的に使用しているが、ブロッキングI/Oが混在。
*   **外部API**: Anthropic API への依存。

## 2. 要件適合性分析 (Requirements Feasibility Analysis)

要件書 (`requirements.md`) に基づくギャップ分析結果は以下の通りです。

| 要件ID | 要件項目 | 現状とのギャップ | 分類 |
| :--- | :--- | :--- | :--- |
| **1.1-1.3** | プラグインロードの非同期化・タイムアウト・隔離 | `load` メソッドが同期的であり、タイムアウト制御も不完全。例外ハンドリングは存在するが、非同期化が必須。 | **Missing** |
| **1.4** | プラグイン同時ロード数制限 | 実装なし。 | **Missing** |
| **2.1-2.2** | LLM同時実行数上限と待機 | `ConsensusEngine` は無制限に並列化する。`LLMClient` にセマフォ等の制御がない。 | **Missing** |
| **3.1-3.2** | ストリーミングのバックプレッシャー | ドロップロジックのみ実装。`put` (待機) と `put_nowait` (ドロップ) の切り替え機構が必要。 | **Constraint** |
| **4.1-4.2** | DIによる依存性注入 | 一部実装済み (`llm_client_factory`) だが、主要マネージャ群がハードコードされている。 | **Constraint** |
| **5.1-5.4** | 設定値の一元管理とPydantic移行 | 現在は `ConfigManager` で手動管理。Pydantic への全面的リファクタリングが必要。 | **Missing** |
| **6.1-6.4** | 宣言的バリデーション | 全面的に不足。手動 `if` チェックが主流。 | **Missing** |
| **8.1-8.4** | プラグイン権限分離 | `agent_overrides` が無条件に適用される。権限チェックロジックがない。 | **Missing** |
| **9.1** | 本番運用モードでの鍵パス厳格化 | フォールバックロジックが常に有効。モードによる分岐が必要。 | **Missing** |

**主な調査事項 (Research Needed)**:
*   `aiofiles` 導入による既存テストへの影響（モックの修正範囲）。
*   Pydantic V2 導入時の既存コード（特に `dataclass` 前提の箇所）への影響範囲。

## 3. 実装アプローチ案 (Implementation Approach Options)

### Option A: 既存コンポーネントの段階的リファクタリング (推奨)
既存のクラス構造を維持しつつ、内部実装を要件に合わせて強化するアプローチです。

*   **概要**:
    *   **Config**: `Config` クラスを Pydantic の `BaseModel` に置き換え、`ConfigManager` を簡素化。
    *   **PluginLoader**: `load` を `async def load` に変更し、内部で `aiofiles` と `run_in_executor` を使用。
    *   **ConsensusEngine**: コンストラクタ引数を追加し、デフォルト引数で従来のインスタンス生成を行う（後方互換性維持）。
    *   **LLMClient**: `asyncio.Semaphore` を導入して同時実行数を制御。
*   **メリット**:
    *   既存の統合テストや利用コードへの影響を最小限に抑えられる。
    *   段階的な適用が可能。
*   **デメリット**:
    *   `dataclass` から Pydantic への移行で、型チェック等の挙動が変わり、一時的にテストが壊れる可能性がある。
*   **トレードオフ**:
    *   ✅ 既存パターンの活用
    *   ✅ ファイル数の増加を抑制
    *   ❌ リファクタリング中の回帰テスト負荷が高い

### Option B: 新規ハードニングコンポーネントの作成と置換
新しい要件を満たすクラス（例: `HardenedPluginLoader`, `SecureConsensusEngine`）を新規作成し、入れ替えるアプローチです。

*   **概要**:
    *   既存クラスはそのまま残し（Legacyとしてマーク）、新クラスをゼロから実装。
*   **メリット**:
    *   既存の動作を壊さずに安全に開発できる。
    *   古い設計の制約を受けずにクリーンな実装が可能。
*   **デメリット**:
    *   コードの重複が発生する。
    *   移行期間中のメンテナンスコストが増大する。
*   **トレードオフ**:
    *   ✅ クリーンな設計
    *   ❌ ファイル数と重複コードの増加

## 4. 推奨事項と次のステップ

### 推奨アプローチ
**Option A（段階的リファクタリング）** を推奨します。現状のコードベースは比較的小規模であり、完全に分離するよりも、既存コンポーネントを成熟させる方が長期的な保守性の観点で望ましいためです。

### 複雑性とリスク
*   **Effort**: **L (1-2 weeks)**
    *   Pydantic への移行と非同期化は、多くのファイルに波及する変更です。
*   **Risk**: **Medium**
    *   並行処理の変更（非同期I/O化、セマフォ導入）は、デッドロックやレースコンディションの新たな原因となる可能性があります。

### Designフェーズへの申し送り事項
1.  **Pydantic モデル設計**: 設定 (`Config`)、プラグイン定義 (`Plugin`)、API リクエスト/レスポンス構造を Pydantic モデルとして再定義する詳細設計が必要です。
2.  **非同期I/O戦略**: `aiofiles` を導入するか、標準の `run_in_executor` で対応するかの方針決定。依存ライブラリを増やしたくない場合は後者が有利です。
3.  **DI コンテナの要否**: 本格的な DI コンテナ（Dependency Injectorなど）を入れるか、現在のコンストラクタ注入（Pure DI）で十分かの判断。現状規模なら Pure DI で十分と想定されます。
