# 要件ドキュメント

## プロジェクト説明（入力）
### 1. 性能 (Performance)

非同期処理 (`asyncio`) が導入されていますが、一部の実装が並行性のメリットを最大限に活かせていない、あるいはリソース枯渇のリスクがある箇所が見受けられます。

* **課題: I/Oバウンドな処理におけるブロッキング操作の残存**
    * **理由:** `PluginLoader` クラス内の `load` メソッドおよび `_verify_security` メソッドにおいて、ファイルの読み込み (`path.read_text`) やハッシュ計算といった処理が同期的に行われています。プラグイン数が数個であれば問題ありませんが、多数のプラグインをロードする場合や、ファイルシステムが低速な環境（ネットワークマウントなど）では、これがアプリケーション起動時のボトルネックとなり、イベントループをブロックする可能性があります。
    * **改善案:** ファイルI/Oには `aiofiles` などの非同期ライブラリを使用するか、CPUバウンドな処理（署名検証やハッシュ計算など）とともに `asyncio.to_thread` (Python 3.9+) や `run_in_executor` を用いてスレッドプールにオフロードすることを推奨します。

* **課題: LLMリクエストの同時実行数制御（スロットリング）の欠如**
    * **理由:** `ConsensusEngine` は `asyncio.gather` を用いて全エージェントの思考や投票を並列に実行します。しかし、グローバルな同時実行数の制限（セマフォ等）が見当たりません。エージェント数が増加したり、リトライが重なった場合、短期間に大量のリクエストがAPIに送信され、プロバイダ（Anthropic）側のレート制限に即座に抵触するリスクがあります。`LLMClient` 内のリトライロジック だけでは、システム全体のスループット制御としては不十分です。
    * **改善案:** `TokenBudgetManager` のような予算管理に加え、`asyncio.Semaphore` を用いた「同時リクエスト数の制限」を `LLMClient` または `ConsensusEngine` レベルで導入してください。これにより、スパイクアクセスを平準化し、安定した動作を保証できます。

* **課題: ストリーミングバッファのメモリ効率とドロップ戦略**
    * **理由:** `QueueStreamingEmitter` は固定長のキュー (`queue_size=100`) を持ち、溢れた場合はログを出してドロップする仕様です。高負荷時に重要な思考プロセスの一部が欠落する可能性があり、ユーザー体験やデバッグ容易性を損ないます。
    * **改善案:** 単純なドロップではなく、バックプレッシャー（`put` 側を待機させる）の導入や、リングバッファ構造の採用を検討してください。また、大量の文字列結合 (`"".join(self._stream_buffer)`) が頻繁に行われる箇所 は、メモリ割り当てのコストが高いため、リスト構造のまま扱うか、結合頻度を調整する最適化が有効です。

### 2. 品質 (Quality)

コードは清潔ですが、結合度の高さや設定管理の面で、長期的な保守性に課題があります。

* **課題: 依存性の注入 (DI) の不徹底によるテスト容易性の低下**
    * **理由:** `ConsensusEngine` のコンストラクタ内で、`PersonaManager` や `ContextManager` が直接インスタンス化されています。これにより、これらのコンポーネントをモックに差し替えて `ConsensusEngine` 単体をテストすることが困難になっています（密結合）。
    * **改善案:** これらの依存オブジェクトはコンストラクタの引数として外部から注入できるように変更してください。デフォルト引数としてファクトリ関数や既存のクラスを使用することで、利便性を損なわずにテスト容易性を劇的に向上させることができます。

* **課題: 設定値の散在とハードコーディング**
    * **理由:** `LLMClient` のデフォルトモデル名 `"claude-sonnet-4-20250514"` やタイムアウト値などがコード内に直接記述されています。また、`PluginLoader` でもタイムアウトのデフォルト値 `30` がハードコードされています。これらが分散していると、設定変更時の影響範囲調査が困難になります。
    * **改善案:** 全ての設定値を `magi.config` モジュールや設定クラスに集約し、各クラスはそこから値を参照するように統一してください。定数は一箇所で管理されるべきです。

* **課題: バリデーションロジックの重複と脆弱性**
    * **理由:** `PluginLoader` 内で手動による辞書構造のチェック (`isinstance` の多用) が行われています。これはコードが冗長になるだけでなく、仕様変更時の修正漏れを招きやすい実装です。
    * **改善案:** `Pydantic` のようなデータバリデーションライブラリの導入を強く推奨します。宣言的なモデル定義により、コード量を削減しつつ、型安全性とバリデーションの堅牢性を同時に確保できます。

### 3. セキュリティ (Security)

AIシステム特有のリスクと、一般的なアプリケーションセキュリティの両面で強化が必要です。

* **課題: ヒューリスティックベースのガードレールの限界**
    * **理由:** `HeuristicGuardrailsProvider` は正規表現を用いてプロンプトインジェクションを検知していますが、攻撃者は表記ゆれや分割入力、難読化を用いて容易にこれらのルールを回避可能です（例: Base64チェックはデコード後の再帰的なチェックを行っていないようです）。これは「深層防護」としては弱すぎます。
    * **改善案:** 正規表現によるフィルタは「最初の砦」として維持しつつ、より高度な判定ロジック（例: 入力解析専用の軽量LLMによる意図分類や、LLM Guardのような専門ライブラリの採用）をプロバイダとして追加できるように拡張してください。

* **課題: プラグインによるプロンプト汚染のリスク**
    * **理由:** `PluginLoader` では `agent_overrides` を通じてエージェントのプロンプトを上書きできます。悪意のあるプラグイン（または改ざんされたプラグイン）がシステムプロンプトを書き換え、合議プロセスを特定の結論に誘導したり、機密情報を漏洩させたりするリスクがあります。
    * **改善案:** プラグインが上書きできるプロンプトの範囲を制限する（例: システムプロンプト全体ではなく、追加のコンテキストのみ許可する）、あるいは署名検証済みの信頼された発行元のプラグインのみにこの権限を与えるといった、権限分離の仕組みが必要です。

* **課題: 公開鍵パス解決の曖昧さ**
    * **理由:** `_resolve_public_key_path` メソッドは、設定、環境変数、カレントディレクトリの順で公開鍵を探します。開発環境では便利ですが、本番環境で意図しない（攻撃者が配置した）鍵を読み込んでしまうリスクがあります（CWD汚染など）。
    * **改善案:** 本番運用モード（Production Mode）のようなフラグを用意し、その場合は環境変数や絶対パスでの指定のみを許可し、フォールバックロジックを無効化する厳格なモードを実装すべきです。

### 4. 総評

MAGIシステムは概念実証（PoC）やアルファ版としては高い完成度を持っていますが、ミッションクリティカルな意思決定支援に使用するには、特に**「並行処理の制御」「依存関係の整理」「入力検証の強化」**が必要です。まずは `Pydantic` への移行によるコード整理と、並行リクエスト制御の実装から着手することをお勧めします。

## はじめに
本仕様では、MAGI System のハードニングとリファクタリングを通じて、性能（起動・並行性）、信頼性（過負荷時の安定動作）、保守性（依存関係と設定の整理）、セキュリティ（入力境界・プラグイン境界・鍵運用）の一貫性を向上させる。特に、(1) プラグインロードと検証の安全な実行、(2) LLM 呼び出しの同時実行制御、(3) ストリーミング出力のバックプレッシャと可観測性、(4) DI と設定・検証の統一、(5) Guardrails とプラグイン権限分離、(6) 本番運用を想定した鍵パス解決の厳格化を対象とする。

## 要件

### 1. プラグインロードの安定性と資源保護
**目的:** 運用者として、起動時や実行時のプラグインロードが全体の応答性を損なわず、安全に失敗できるようにしたいので、ロード処理のタイムアウト・キャンセル・隔離と監査可能なログがほしい。

#### 受入基準
1. When プラグインロードが開始されたとき, the MAGI Core shall 各プラグインのロードと検証に個別のタイムアウトを適用する。
2. If プラグインのロードまたは検証がタイムアウトした場合, the MAGI Core shall 当該プラグインを無効化し、起動/処理を継続し、失敗理由とプラグイン識別子をログに記録する。
3. If プラグインのロードまたは検証が失敗した場合, the MAGI Core shall 失敗したプラグインの影響が他プラグインや合議処理に波及しないよう隔離する。
4. While 複数プラグインのロードが同時に進行している間, the MAGI Core shall 同時ロード数に上限を設け、上限を超えるロード要求を待機または抑止する。
5. The MAGI Core shall プラグインロードの開始・終了・所要時間・成功/失敗件数を監査可能な形式でログに記録する。

### 2. LLM 呼び出しの同時実行制御と過負荷耐性
**目的:** CLI 利用者として、エージェント数やリトライが増えても安定して合議結果を得たいので、LLM 呼び出しの同時実行を制御し、レート制限時にも破綻しない挙動がほしい。

#### 受入基準
1. The MAGI Core shall LLM への送信リクエストに対してプロセス全体の同時実行上限を適用する。
2. When 同時実行上限に到達したとき, the MAGI Core shall 新規の LLM 呼び出しを待機または拒否し、選択された方針（待機/拒否）をログに記録する。
3. If LLM プロバイダからレート制限または過負荷を示すエラーが返った場合, the MAGI Core shall 再試行をスパイクさせないよう抑制し、再試行が抑制された事実と理由をログに記録する。
4. While 合議処理が進行している間, the MAGI Core shall エージェントごとの失敗が発生しても、クオーラム未達や停止条件に達するまで処理を継続できる。
5. The MAGI Core shall LLM 呼び出しの同時実行数、待機数、レート制限発生回数を観測可能な形で記録する。

### 3. ストリーミング出力のバックプレッシャと欠落管理
**目的:** CLI 利用者として、高負荷時でもストリーミング出力の一貫性と可観測性を保ちたいので、キュー溢れ時の方針と欠落の扱いが明確であってほしい。

#### 受入基準
1. The MAGI Core shall ストリーミング出力のバッファ上限とキュー溢れ時の方針を設定で制御できるようにする。
2. When ストリーミングバッファが上限に達したとき, the MAGI Core shall 設定された方針に従ってバックプレッシャ適用または出力欠落を処理する。
3. If ストリーミング出力が欠落した場合, the MAGI Core shall 欠落件数、欠落区間（可能な範囲）、発生理由をログおよびイベントに記録する。
4. While ストリーミング出力が有効な間, the MAGI Core shall 最終結果（合議の結論および要約）が欠落しないよう保証する。
5. The MAGI Core shall ストリーミングの TTFB、送出遅延、欠落率を観測可能な形で記録する。

### 4. 依存性注入（DI）によるテスト容易性
**目的:** 開発者として、合議エンジンを単体テストしやすくしたいので、主要コンポーネントの依存関係を差し替え可能にし、外部 I/O に依存せずに検証できるようにしたい。

#### 受入基準
1. The MAGI Core shall Consensus Engine の主要依存（例: persona/context 管理、LLM クライアント、ストリーミング出力、設定）を外部から注入可能にする。
2. When 依存が注入されない場合, the MAGI Core shall 互換性のあるデフォルト実装を用いて動作する。
3. While 単体テスト用にモック依存が注入されている間, the MAGI Core shall ネットワークアクセスを不要にした状態で合議フローを実行できる。
4. The MAGI Core shall 依存の差し替えにより、合議フローの分岐（成功/失敗/クオーラム未達/リトライ枯渇）を再現可能にする。

### 5. 設定値の一元管理と安全なデフォルト
**目的:** 運用者として、散在したハードコード値による予期しない挙動を避けたいので、設定の定義と優先順位、既定値、バリデーションが一箇所で把握できるようにしたい。

#### 受入基準
1. The MAGI Core shall 全てのユーザー調整可能な設定値について、定義（型、範囲/制約、既定値、説明）を一元化する。
2. When 設定をロードするとき, the MAGI Core shall 設定ソースの優先順位（例: コマンドライン、環境変数、設定ファイル、既定値）を一貫したルールで適用する。
3. If 設定値が型不一致または制約違反である場合, the MAGI Core shall 起動または該当機能の実行を拒否し、修正可能なエラーメッセージを提示する。
4. If 未知の設定キーが指定された場合, the MAGI Core shall それを無視せず、警告またはエラーとして明示する。
5. The MAGI Core shall 実効設定（機微情報をマスクしたもの）を診断可能な形で出力できる。

### 6. 入力・マニフェストの宣言的バリデーション
**目的:** 開発者として、手書き検証の重複や修正漏れを避けたいので、設定/プラグイン定義/外部入力を宣言的に検証し、失敗時の挙動を統一したい。

#### 受入基準
1. The MAGI Core shall 設定ファイル、プラグイン定義、外部入力の主要データ構造に対して宣言的なスキーマに基づく検証を行う。
2. If スキーマ検証が失敗した場合, the MAGI Core shall 失敗箇所（フィールド/パス）と理由を含むエラーを返す。
3. When 検証が必要なデータが読み込まれたとき, the MAGI Core shall 以降の処理（ロード/実行/合議）に進む前に検証を完了させる。
4. The MAGI Core shall 同一種類の検証失敗に対して、常に同一のエラー分類とログ形式を用いる。

### 7. Guardrails の拡張性とフェイルポリシーの明確化
**目的:** セキュリティ担当として、単一のヒューリスティック検知に依存せず、状況に応じてガード手段を強化できるようにしたいので、Guardrails の追加と失敗時ポリシーが明確であってほしい。

#### 受入基準
1. The MAGI Core shall 複数の Guardrails プロバイダを設定により有効化できる。
2. When Guardrails が入力またはコンテキストを評価するとき, the MAGI Core shall 判定結果（許可/拒否/要サニタイズ）と理由コードを監査可能な形で記録する。
3. If Guardrails の評価がタイムアウトまたは例外で失敗した場合, the MAGI Core shall 設定されたポリシー（fail-open または fail-closed）に従って処理し、適用ポリシーをログに記録する。
4. Where Guardrails が拒否または要サニタイズを返す場合, the MAGI Core shall LLM への送信前に要求を遮断または安全化し、ユーザーに実行可能なメッセージを返す。

### 8. プラグインによるプロンプト上書き権限の分離
**目的:** セキュリティ担当として、プラグインが合議を恣意的に誘導したり機密情報を引き出したりするリスクを抑えたいので、プロンプト変更の権限と監査を分離したい。

#### 受入基準
1. The MAGI Core shall プラグインによるプロンプト変更について、許可される範囲（例: 追加コンテキストのみ）を設定で制御できる。
2. If プラグインが許可されない範囲のプロンプト変更を要求した場合, the MAGI Core shall その変更を拒否し、プラグイン識別子と拒否理由をログに記録する。
3. Where 信頼されたプラグインのみが強い権限（例: 上書き）を必要とする場合, the MAGI Core shall 信頼判定（例: 署名検証や許可リスト）に基づいて権限付与を行う。
4. The MAGI Core shall プロンプト変更が適用された場合に、適用された変更種別と適用元（プラグイン識別子）を監査可能な形で記録する。

### 9. 公開鍵パス解決の厳格化（本番運用）
**目的:** 運用者として、本番環境で意図しない公開鍵を読み込むリスクを避けたいので、公開鍵の探索ロジックを厳格化し、曖昧なフォールバックを排除したい。

#### 受入基準
1. Where 本番運用モードが有効な場合, the MAGI Core shall 公開鍵パスを明示指定されたソースのみから解決し、曖昧な探索（例: カレントディレクトリからの探索）を行わない。
2. If 本番運用モードで公開鍵パスが解決できない場合, the MAGI Core shall 起動またはプラグイン検証を拒否し、解決に必要な設定項目を明示したエラーを返す。
3. When 公開鍵パスが解決されたとき, the MAGI Core shall 解決元（例: 設定/環境変数/既定パス）を監査可能な形で記録する。
